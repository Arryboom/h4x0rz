# h4x0rz
using System; using System.Collections.Generic; using System.Diagnostics; using System.Runtime.InteropServices; using System.Threading;  namespace csgoHax {     class GerenciaMemoria     {               [DllImport("kernel32.dll")]         public static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);         [DllImport("kernel32.dll")]         public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, ref IntPtr lpNumberOfBytesRead);         [DllImport("kernel32.dll")]         public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, int lpNumberOfBytesWritten);         [DllImport("kernel32.dll")]         public static extern bool CloseHandle(int hObject);         [DllImport("user32.dll", EntryPoint = "FindWindow", SetLastError = true)]         public static extern IntPtr FindWindowByCaption(IntPtr ZeroOnly, string lpWindowName);            Process[] MeuProcesso;          private IntPtr controladorProcesso = IntPtr.Zero;          public IntPtr endBaseCliente = IntPtr.Zero;         public int tamModuloCliente;         public IntPtr endBaseMotor = IntPtr.Zero;         public int tamBaseMotor;                  public bool Inicia(string nomeProcesso = "csgo", string nomeJanela = "Counter-Strike: Global Offensive")         {             MeuProcesso = Process.GetProcessesByName(nomeProcesso);              if (nomeProcesso == "")                 return false;              if (MeuProcesso == null || MeuProcesso.Length == 0)                 return false;              if ((controladorProcesso = OpenProcess(2035711, false, MeuProcesso[0].Id)) == IntPtr.Zero)                 return false;              if (FindWindowByCaption(IntPtr.Zero, nomeJanela) == IntPtr.Zero)                 return false;              if ((endBaseCliente = EndImagemDll("client.dll", out tamModuloCliente)) == IntPtr.Zero)                 return false;              if ((endBaseMotor = EndImagemDll("engine.dll", out tamBaseMotor)) == IntPtr.Zero)                 return false;              return true;         }           public IntPtr EndImagemDll(string nomedll, out int tam)         {             ProcessModuleCollection modulos = MeuProcesso[0].Modules;              foreach (ProcessModule moduloProcesso in modulos)             {                 if (nomedll == moduloProcesso.ModuleName)                 {                     tam = moduloProcesso.ModuleMemorySize;                     return moduloProcesso.BaseAddress;                 }             }             tam = 0;             return IntPtr.Zero;         }          public int EncontraPadrao(byte[] padrao, string mask, string modulo)         {             int tamModulo = 0;             IntPtr moduleBase = EndImagemDll(modulo, out tamModulo);             if (tamModulo == 0)             {                 string errorMessage = string.Format("Size of module {0} is INVALID.", modulo);                 throw new Exception(errorMessage);             }              for (int i = 0; i &lt; tamModulo - mask.Length; i++)             {                 bool encontrado = true;                 IntPtr numBytes = IntPtr.Zero;                 int tam = mask.Length;                 byte[] buffer = new byte[tam];                 if (ReadProcessMemory(controladorProcesso, moduleBase + i, buffer, tam, ref numBytes))                     for (int l = 0; l &lt; mask.Length; l++)                     {                         encontrado = mask[l] == '?' || buffer[l] == padrao[l];                         if (!encontrado)                             break;                     }                  if (encontrado)                     return i;             }             return 0;         }          public int EncontraPadrao(byte[] padrao, string mask, IntPtr baseModulo, int tamModulo)         {             if (tamModulo == 0)             {                 string errorMessage = string.Format("Size of module is INVALID.");                 throw new Exception(errorMessage);             }              for (int i = 0; i &lt; tamModulo - mask.Length; i++)             {                 bool encontrado = true;                 IntPtr numBytes = IntPtr.Zero;                 int tam = mask.Length;                 byte[] buffer = new byte[tam];                 if (ReadProcessMemory(controladorProcesso, baseModulo + i, buffer, tam, ref numBytes))                     for (int l = 0; l &lt; mask.Length; l++)                     {                         encontrado = mask[l] == '?' || buffer[l] == padrao[l];                         if (!encontrado)                             break;                     }                  if (encontrado)                     return i;             }             return 0;         }          public T Read&lt;T>(IntPtr end)         {             IntPtr numBytes = IntPtr.Zero;             int tam = Marshal.SizeOf(typeof(T));             byte[] buffer = new byte[tam];             if (ReadProcessMemory(controladorProcesso, end, buffer, tam, ref numBytes))                 return BytesToT&lt;T>(buffer);              return default(T);         }          public T BytesToT&lt;T>(byte[] data, T defVal = default(T))         {             T estrutura = defVal;             GCHandle gcHandle = GCHandle.Alloc(data, GCHandleType.Pinned);             estrutura = (T)Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof(T));             gcHandle.Free();              return estrutura;         }          public void Write&lt;T>(IntPtr end, T toWrite = default(T)) where T : struct         {             int tam = Marshal.SizeOf(typeof(T));             WriteProcessMemory(controladorProcesso, end, TToBytes(toWrite), tam, 0);              return;         }          public byte[] TToBytes&lt;T>(T value) where T : struct         {             int tam = Marshal.SizeOf(typeof(T));             byte[] data = new byte[tam];              IntPtr ptr = Marshal.AllocHGlobal(tam);             Marshal.StructureToPtr(value, ptr, true);             Marshal.Copy(ptr, data, 0, tam);             Marshal.FreeHGlobal(ptr);              return data;         }     }      class Offsets     {           public static int LocalPlayer = 0;         public static int ObjectBase = 0;         public static int EntityList = 0;          public static class CSPlayer         {             public static int health = 0xFC;             public static int teamNum = 0xF0;             public static int m_bDormant = 0xE9;             public static int bSpotted = 0x939;             public static int index = 0x64;             public static int glowIndex = 0xA320;         }          public static void AtualizaOffsets(GerenciaMemoria gMem)         {             GetPlayerLocal(gMem);             GetBaseObjeto(gMem);             GetListaEntidades(gMem);         }          static void GetPlayerLocal(GerenciaMemoria gMem)         {             int end;             end = gMem.EncontraPadrao(new byte[] { 0xFC, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x3D }, "xx????xx", gMem.endBaseCliente, gMem.tamModuloCliente) + 8;             LocalPlayer = gMem.Read&lt;int>(gMem.endBaseCliente + end) - gMem.endBaseCliente.ToInt32();         }          static void GetBaseObjeto(GerenciaMemoria gMem)         {             int end;             end = gMem.EncontraPadrao(new byte[] { 0xE8, 0x0, 0x0, 0x0, 0x0, 0x83, 0xC4, 0x04, 0xB8, 0x0, 0x0, 0x0, 0x0, 0xC3, 0xcc }, "x????xxxx????xx", gMem.endBaseCliente, gMem.tamModuloCliente) + 9;             ObjectBase = gMem.Read&lt;int>(gMem.endBaseCliente + end) - gMem.endBaseCliente.ToInt32();         }          static void GetListaEntidades(GerenciaMemoria gMem)         {             int end;             end = gMem.EncontraPadrao(new byte[] { 0xBB, 0x00, 0x00, 0x00, 0x00, 0x83, 0xFF, 0x01, 0x0F, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xF8 }, "x????xxxxx????xx", gMem.endBaseCliente, gMem.tamModuloCliente) + 1;             EntityList = gMem.Read&lt;int>(gMem.endBaseCliente + end) - gMem.endBaseCliente.ToInt32();         }     }      class Player     {         public IntPtr baseAddr;         public int index;         public int vida;         public int time;         public bool dormente;         public bool estaVivo;         public int glowIndex;          public Player() { }                  public Player(GerenciaMemoria gMem, int index)         {             baseAddr = (IntPtr)gMem.Read&lt;uint>(gMem.endBaseCliente + Offsets.EntityList + ((index - 1) * 16));             this.index = index;             vida = gMem.Read&lt;int>(baseAddr + Offsets.CSPlayer.health);             glowIndex = gMem.Read&lt;int>(baseAddr + Offsets.CSPlayer.glowIndex);             time = gMem.Read&lt;int>(baseAddr + Offsets.CSPlayer.teamNum);             dormente = gMem.Read&lt;bool>(baseAddr + Offsets.CSPlayer.m_bDormant);             estaVivo = vida > 0;         }     }      class LocalPlayer : Player     {         public LocalPlayer(GerenciaMemoria gMem)         {             baseAddr = (IntPtr)gMem.Read&lt;uint>(gMem.endBaseCliente + Offsets.LocalPlayer);             index = gMem.Read&lt;int>(baseAddr + Offsets.CSPlayer.index);             time = gMem.Read&lt;int>(baseAddr + Offsets.CSPlayer.teamNum);         }     }      class ListaEntidades     {         public LocalPlayer local;         public List&lt;Player> jogadores = new List&lt;Player>();              public ListaEntidades(GerenciaMemoria gMem)         {             local = new LocalPlayer(gMem);             for (int i = 0; i &lt; 64; i++)             {                 if (i != local.index)                     jogadores.Add(new Player(gMem, i));             }         }          public Player GetPlayer(GerenciaMemoria gMem, int index)         {             return new Player(gMem, index);         }     }      class Wallhack     {                IntPtr glowObj;          public Wallhack(IntPtr glowObj)         {             this.glowObj = glowObj;         }                 public void SetGlow(Player jogador, GerenciaMemoria gMem, Color color)         {             gMem.Write(glowObj + (jogador.glowIndex * 0x38 + 0x24), 1);             gMem.Write(glowObj + (jogador.glowIndex * 0x38 + 0x25), 0);             gMem.Write(glowObj + (jogador.glowIndex * 0x38 + 0x26), 0);             gMem.Write(glowObj + (jogador.glowIndex * 0x38 + 0x4), color);         }                 public void SetSpotted(Player player, GerenciaMemoria Mem)         {             Mem.Write(player.baseAddr + Offsets.CSPlayer.bSpotted, true);         }     }      struct Color     {         float r, g, b, a;         public Color(float r, float g, float b)         {             this.r = r / 255;             this.g = g / 255;             this.b = b / 255;                       a = 0.6f;         }     }      class Program     {                 [DllImport("user32.dll")]         public static extern short GetAsyncKeyState(int vKey);          static void Main(string[] args)         {             GerenciaMemoria gMem;             bool radarOn = true, espOn = true;              Console.WriteLine("Made by Sapphire");             Console.Title = "CSGO Hack by Sapphire";                         do             {                 gMem = new GerenciaMemoria();              } while (!gMem.Inicia());              Console.WriteLine("Game found!");             Console.WriteLine(">Updating offsets");                        Offsets.AtualizaOffsets(gMem);              Console.WriteLine("Local Player: " + Offsets.LocalPlayer.ToString("X"));             Console.WriteLine("Object Base: " + Offsets.ObjectBase.ToString("X"));             Console.WriteLine("List of Entities: " + Offsets.EntityList.ToString("X"));             Console.WriteLine("\n>GL/HF!");             Console.WriteLine("\nF6 Wallhack");             Console.WriteLine("F7 Radar\n");                        while (true)             {                              if (Convert.ToBoolean(GetAsyncKeyState(0x76) &amp; 1))                 {                     radarOn = !radarOn;                     Console.WriteLine("Radar: " + radarOn);                 }                             if (Convert.ToBoolean(GetAsyncKeyState(0x75) &amp; 1))                 {                     espOn = !espOn;                     Console.WriteLine("Wallhack: " + espOn);                 }                  ListaEntidades entList = new ListaEntidades(gMem);                 Wallhack wh = new Wallhack((IntPtr)gMem.Read&lt;uint>(gMem.endBaseCliente + Offsets.ObjectBase));                  foreach (var jogador in entList.jogadores)                 {                                         if (jogador.estaVivo &amp;&amp; !jogador.dormente)                     {                                               if (jogador.time != entList.local.time)                         {                                                         if (radarOn)                                 wh.SetSpotted(jogador, gMem);                                                        if (espOn)                                 wh.SetGlow(jogador, gMem, new Color(255 - jogador.vida * 2.55f, jogador.vida * 2.55f, 0));                         }                         else                         {                             /* Schimba culoare propriei echipa daca (espOn)                                 wh.SetGlow(jogador, gMem, new Color(0, 0, 255.0f));                             */                         }                     }                 }                                 Thread.Sleep(1);             }         }     } }
